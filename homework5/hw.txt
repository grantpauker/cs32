1. a)          50
              /  \
            20    60
         /    \      \
       10      40     70
        \     /       / \
         15  30      64  80
            /  \         /
           23    36     75  
b)
Preorder: 50, 20, 10, 15, 40, 30, 23, 36, 60, 70, 64, 80, 75
In order: 10, 15, 20, 23, 30, 36, 40, 50, 60, 64, 70, 75, 80
Postorder: 15, 10, 23, 36, 30, 40, 20, 64, 75, 80, 70, 60, 50

c)             50
              /  \
            23    60
         /    \      \
       10      40     70
        \     /       / \
         15  36      64  80
                         /
                        75  
2.a)
struct Node
{
    Node* left;
    Node* right;
    Node* parent;
    int value;
}
b) 
if tree is empty:
    make new node with parent pointer = null
curNode = root
while key != curNode.key:
    if key < curNode.key:
        if curNode.left == null:
            insert new Node at curNode.left with parentPointer at curNode
        else:
            curNode = curNode.left
    else: //key > curNode.key
        if curNode.right == null:
            insert new Node at curNode.right with parentPointer at curNode
        else:
            curNode = curNode.right

3.a)      7
         / \
        5   6
       / \  /
      3  1  2
b) 7 5 6 3 1 2
c) 6 5 2 3 1

4. a) O(C + S)
b) O(log C + S)
c) O(log C + log S)
d) O(log S)
e) O(1)
f) O(log C + S)
g) O(S log S)
h) O(C log S)
